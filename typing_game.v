
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module typing_game(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD
);


//=======================================================
//  REG/WIRE declarations
//=======================================================

	parameter [31:0]TIME=10000000;//time break to update
	parameter [31:0]TIME_NEW_CHAR=250000000;
	parameter [31:0]MAX_CHAR=50;

reg [3:0]status=0;
reg [3:0]old_status=0;
parameter	   none=0,	 upt_pos=1,	 	delete=2,	draw_fst=3,
			chg_mem=4,	draw_sec=5,		RESET=6,	key_event=7,	create_new=8;

reg	[31:0]cnt=0;//达到TIME时更新位置。
reg f_none=0,f_upt_pos=0, f_delete=0, f_draw_fst=0, f_chg_mem=0,	f_draw_sec=0, f_key_event=0, f_create_new=0;
wire reset;
assign reset=SW[0];
wire new_in;
wire [7:0]code_in;

reg [9:0]endlink=5;	//最多40*24=960

reg	[8:0]k_x[MAX_CHAR:0];
reg [7:0]k_y[MAX_CHAR:0];
reg [7:0]k_text[MAX_CHAR:0];
reg [MAX_CHAR:0]k_v;

reg [2:0] x_fst=0;
reg [2:0] y_fst=0;

reg [31:0]cnt_newchar=0;

integer upt_pos_cnt=0;
integer delete_cnt=0;
reg [31:0] dnum=0;
integer draw_fst_cnt=0;
integer chg_mem_cnt=0;
integer draw_sec_cnt=0;
integer key_event_cnt=0;

reg [31:0]hit=0;
reg [31:0]miss=0;

wire [9:0] h_addr;
wire [9:0] v_addr;
wire [9:0]x_addr;
	assign x_addr=(h_addr>=160 && h_addr<480)? h_addr-160:0;
wire [9:0]y_addr;
	assign y_addr=(v_addr>=140&&v_addr<=340)?v_addr-140:0;

reg [23:0]vga_data;

reg flag1=0;
reg flag2=0;
	initial begin
		endlink=10'd5;
		k_x[0]=80;k_y[0]=9;k_v[0]=0;k_text[0]=8'd66;
		k_x[1]=90;k_y[1]=9;k_v[1]=0;k_text[1]=8'd65;
		k_x[2]=100;k_y[2]=9;k_v[2]=0;k_text[2]=8'd65;
		k_x[3]=110;k_y[3]=9;k_v[3]=0;k_text[3]=8'd65;
		k_x[4]=120;k_y[4]=9;k_v[4]=0;k_text[4]=8'd65;
	end

//=======================================================
//  Structural coding
//=======================================================
wire [7:0] ramdomchar;
wire [7:0] ramdomnum;
wire [8:0] ramdomx;
assign  ramdomchar=(ramdomnum+endlink[7:0])%26;

ramdomnum getramdomnum(
	.clk(CLOCK_50),
	.q(ramdomnum)
);

ramdomx getx(
	.clk(CLOCK_50),
	.q(ramdomx)
);
mem mem1(.clock(CLOCK_50),.data(mem_din),.rdaddress(mem_rpos),.wraddress(mem_wpos),.wren(1'b1),.q(mem_dout));
	reg mem_enw=0;
	wire mem_din,mem_dout;
	wire [16:0]mem_rpos,mem_wpos;
	reg [8:0]mem_x=0;
	reg [7:0]mem_y=0;
	assign mem_wpos={mem_y,mem_x};
	assign mem_rpos={y_addr[7:0],x_addr[8:0]};

canvas canvas1(.clock(CLOCK_50),.data(can_din),.rdaddress(can_rpos),.wraddress(can_wpos),.wren(1'b1),.q(mem_din));
	reg canvas_enw=0;
	reg can_din=0;
	wire [16:0]can_wpos,can_rpos;
	reg [8:0]canvas_x=0;
	reg [7:0]canvas_y=0;
	wire can_dout;
	assign can_wpos={canvas_y,canvas_x};
	assign can_rpos={mem_y,mem_x};

char char1(.address(char_pos), .clock(CLOCK_50), .q(char_row));
	reg [9:0]char_pos=0;
	wire [7:0]char_row;

seg_h seg1(.data_d(status),.out_q(HEX0),.en(1));
seg_h seg2(.data_d(endlink[3:0]),.out_q(HEX1),.en(1));
seg_h seg3(.data_d(dnum[3:0]),.out_q(HEX2),.en(1));
keyboard keyboard1(.clk(CLOCK_50),.clrn(reset),.ps2_clk(PS2_CLK),.ps2_data(PS2_DAT),.asc(code_in),.en(new_in));

clkgen #(25000000) clk25(.clkin(CLOCK_50),.rst(reset),.clken(1'b1),.clkout(VGA_CLK));

vga_ctrl vga_ctrlor(
	.pclk(VGA_CLK), 		//25MHz时钟
	.reset(reset), 		//置位
	.vga_data(vga_data), 	// 上 层 模 块 提 供 的 VGA颜色数据
	.h_addr(h_addr), 	// 提 供 给 上 层 模 块 的 当 前 扫 描 像 素 点 坐 标
	.v_addr(v_addr),
	.hsync(VGA_HS), 		// 行 同 步 和 列 同 步 信 号
	.vsync(VGA_VS),
	.valid(VGA_BLANK_N), 		//消隐信号
	.vga_r(VGA_R), 		// 红 绿 蓝 颜 色 信 号
	.vga_g(VGA_G),
	.vga_b(VGA_B)
);

//newin
always @(posedge CLOCK_50 or posedge new_in)begin
	if(new_in)begin
		if(flag1==0)begin
			flag1<=1;
			flag2<=1;
		end	else flag2<=0;
	end else begin
		flag1<=0;
		flag2<=0;
 	end
end

//status
always @(posedge CLOCK_50 )begin
	cnt_newchar<=cnt_newchar+1;
	if(reset)begin status<=RESET; old_status<=none;cnt_newchar<=0;end
	else if(flag2)begin old_status<=status; status<=key_event; end
	else if(cnt_newchar==TIME_NEW_CHAR)	begin old_status<=status; status<=create_new;cnt_newchar<=0;end
	else begin
		case (status)
			none 		: if(f_none) 		begin status<=upt_pos;	old_status<=status;	 	end
			upt_pos		: if(f_upt_pos)		begin status<=delete;	old_status<=status;		end
			delete 		: if(f_delete) 		begin status<=draw_sec;	old_status<=status;		end
			draw_fst 	: if(f_draw_fst)	begin status<=chg_mem;	old_status<=status;		end
			chg_mem  	: if(f_chg_mem) 	begin status<=none;	old_status<=status;		end
			draw_sec 	: if(f_draw_sec)	begin status<=draw_fst;		old_status<=status;		end
			RESET   	: if(!reset)		begin status<=none;		old_status<=none;		end
		key_event 	: if(f_key_event)	begin status<=none;						end
		create_new	: if(f_create_new)	begin status<=old_status;						end
		9,10,11,12,13,14,15 :           begin status<=none;		old_status<=none;		end
		endcase
	end
end


//color
always @(posedge CLOCK_50)begin
	if(h_addr<160 || h_addr>=480 || v_addr<140 ||v_addr>=340)begin
		vga_data<=24'h2a0a29;
	end else begin
		vga_data<={	mem_dout,mem_dout,mem_dout,mem_dout,mem_dout,mem_dout,
					mem_dout,mem_dout,mem_dout,mem_dout,mem_dout,mem_dout,
					mem_dout,mem_dout,mem_dout,mem_dout,mem_dout,mem_dout,
					mem_dout,mem_dout,mem_dout,mem_dout,mem_dout,mem_dout};
	end
end

//enw
always@(posedge CLOCK_50)begin
	if(status==draw_fst_cnt || status==draw_sec_cnt)
		canvas_enw<=1;
	else canvas_enw<=0;
	if(status==chg_mem)
		mem_enw<=1;
	else mem_enw<=0;
end

//all case
always @(posedge CLOCK_50)begin
	if(status==create_new && f_create_new==0)begin
		k_x[endlink]<=(ramdomx%9'd312);
		k_y[endlink]<=8'd4;
		k_text[endlink]<=8'd65+ramdomchar;
		k_v[endlink]<=1'd0;
		endlink<=endlink+1;
		f_create_new<=1;
	end else begin f_create_new<=0; end

	if(status==none && f_none==0)begin
		cnt<=cnt+1;
		if(cnt>=TIME)begin
			cnt<=0;
			f_none<=1;
		end
	end else begin f_none <=0;end

	if(status==upt_pos && f_upt_pos==0)begin
		if(upt_pos_cnt>=endlink)begin
			f_upt_pos<=1;
			upt_pos_cnt<=0;
		end else begin
			upt_pos_cnt<=upt_pos_cnt+1;
			if(k_v[upt_pos_cnt]==0)
				k_y[upt_pos_cnt]<=k_y[upt_pos_cnt]+1;
			else if(k_y[upt_pos_cnt]>3)
				k_y[upt_pos_cnt]<=k_y[upt_pos_cnt]-3;
		end
	end else begin f_upt_pos<=0; end

	if(status==delete && f_delete==0) begin
		if(delete_cnt>=endlink)begin
			f_delete<=1;
			delete_cnt<=0;
			endlink<=endlink-dnum;
			dnum<=0;
		end else begin
			delete_cnt<=delete_cnt+1;
			if(k_y[delete_cnt]<4)begin
				dnum<=dnum+1;
				hit<=hit+1;
			end else if(k_y[delete_cnt]>=193)begin
				dnum<=dnum+1;
				miss<=miss+1;
			end else begin
					k_x[delete_cnt-dnum]<=k_x[delete_cnt];
					k_y[delete_cnt-dnum]<=k_y[delete_cnt];
				 k_text[delete_cnt-dnum]<=k_text[delete_cnt];
					k_v[delete_cnt-dnum]<=k_v[delete_cnt];
			end
		end
	end else begin f_delete<=0; end

	if(status==draw_fst && f_draw_fst==0) begin
		if(draw_fst_cnt>=endlink)begin
			f_draw_fst<=1;
			draw_fst_cnt<=0;
			x_fst<=0;
			y_fst<=0;
			canvas_y<=0;
			canvas_x<=0;
			char_pos<=0;
			can_din<=0;
		end	else begin
			if(x_fst>=7)begin
				x_fst<=0;
				if(y_fst>=7)begin
					draw_fst_cnt<=draw_fst_cnt+1;
					y_fst<=0;
				end else begin
					y_fst<=y_fst+1;
				end
			end else begin
				x_fst<=x_fst+1;
			end
			canvas_y<=k_y[draw_fst_cnt]+y_fst;
			canvas_x<=k_x[draw_fst_cnt]+x_fst;
			char_pos<={k_text[draw_fst_cnt],y_fst};
			can_din<=char_row[x_fst];
		end
	end else begin f_draw_fst<=0; end

	if(status==chg_mem && f_chg_mem==0)begin
		if(chg_mem_cnt>=200)begin
			f_chg_mem<=1;
			chg_mem_cnt<=0;
			mem_y<=0;
			mem_x<=0;
		end else begin
			if(mem_x+1>=320)begin
				mem_x<=0;
				chg_mem_cnt<=chg_mem_cnt+1;
				mem_y<=mem_y+1;
   			end else begin mem_x<=mem_x+1; end
		end
	end else begin f_chg_mem<=0; end

	if(status==draw_sec && f_draw_sec==0)begin
		if(draw_sec_cnt>=200)begin
			f_draw_sec<=1;
			draw_sec_cnt<=0;
			canvas_y<=0;
			canvas_x<=0;
		end else begin
			if(canvas_x+1>=320)begin
				draw_sec_cnt<=draw_sec_cnt+1;
				canvas_x<=0;
				canvas_y<=canvas_y+1;
			end else begin canvas_x<=canvas_x+1; end
		end
		can_din<=1'b0;
	end else begin f_draw_sec<=0; end

	if(status==key_event && f_key_event==0) begin
		if(f_key_event==0)begin
			if(key_event_cnt>=endlink)begin
				f_key_event<=1;
				key_event_cnt<=0;
			end else begin
				key_event_cnt<=key_event_cnt+1;

				if(k_text[key_event_cnt]==code_in)begin
					k_v[key_event_cnt]<=1;
					f_key_event<=1;
					key_event_cnt<=0;
				end
			end
		end else begin
			f_key_event<=1;
		end
 	end else begin f_key_event<=0; end

end

endmodule
