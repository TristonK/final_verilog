
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module typing_game(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD
);


//=======================================================
//  REG/WIRE declarations
//=======================================================

	parameter [31:0]TIME=10000000;//time break to update
	parameter [31:0]TIME_NEW_CHAR=250000000;
	parameter [31:0]MAX_CHAR=50;

reg [3:0]status=0;
reg [3:0]old_status=0;
parameter	   none=0,	 upt_pos=1,	 	delete=2,	draw_fst=3,
			chg_mem=4,	draw_sec=5,		RESET=6,	key_event=7,	create_new=8;

reg	[31:0]cnt=0;//达到TIME时更新位置。
reg f_none=0,f_upt_pos=0, f_delete=0, f_draw_fst=0, f_chg_mem=0,	f_draw_sec=0, f_key_event=0, f_create_new=0;
wire reset;
assign reset=SW[0];
wire new_in;
wire [7:0]code_in;

reg [9:0]endlink=0;	//最多40*24=960

reg	[8:0] k_x [MAX_CHAR:0];
reg [7:0] k_y [MAX_CHAR:0];
reg [7:0] k_text [MAX_CHAR:0];
reg [MAX_CHAR:0]k_v;

reg [2:0] x_fst=0;
reg [2:0] y_fst=0;

reg [31:0]cnt_newchar=0;

integer upt_pos_cnt=0;
integer delete_cnt=0;
integer dnum=0;
integer draw_fst_cnt=0;
integer chg_mem_cnt=0;
integer draw_sec_cnt=0;
integer key_event_cnt=0;

reg [31:0]hit=0;
reg [31:0]miss=0;

wire [9:0] h_addr;
wire [9:0] v_addr;
wire [8:0]x_addr;
	assign x_addr=(h_addr>=160 && h_addr<480)? h_addr-160:0;
wire [7:0]y_addr;
	assign y_addr=(v_addr>=140&&v_addr<=340)?v_addr-140:0;

reg [23:0]vga_data;

reg flag=0;
//=======================================================
//  Structural coding
//=======================================================



mem mem1(.clock(CLOCK_50),.data(mem_din),.rdaddress(mem_rpos),.wraddress(mem_wpos),.wren(mem_enw),.q(mem_dout));
	reg mem_enw=0;
	wire mem_din,mem_dout;
	wire [16:0]mem_rpos,mem_wpos;
	reg [8:0]mem_x=0;
	reg [7:0]mem_y=0;
	assign mem_wpos={mem_y,mem_x};
	assign mem_rpos={y_addr,x_addr};

canvas canvas1(.clock(CLOCK_50),.data(can_din),.rdaddress(can_rpos),.wraddress(can_wpos),.wren(1'b1),.q(mem_din));
	reg canvas_enw=0;
	reg can_din=0;
	wire [16:0]can_wpos,can_rpos;
	reg [8:0]canvas_x=0;
	reg [7:0]canvas_y=0;
	wire can_dout;
	assign can_wpos={canvas_y,canvas_x};
	assign can_rpos={mem_y,mem_x};

char char1(.address(char_pos), .clock(CLOCK_50), .q(char_row));
	reg [9:0]char_pos=0;
	wire [7:0]char_row;

seg_h seg1(.data_d(status),.out_q(HEX0),.en(1));
seg_h seg2(.data_d(endlink[3:0]),.out_q(HEX1),.en(1));

keyboard keyboard1(.clk(CLOCK_50),.clrn(reset),.ps2_clk(PS2_CLK),.ps2_data(PS2_DAT),.asc(code_in),.en(new_in));

clkgen #(25000000) clk25(.clkin(CLOCK_50),.rst(reset),.clken(1'b1),.clkout(VGA_CLK));

vga_ctrl vga_ctrlor(
	.pclk(VGA_CLK), 		//25MHz时钟
	.reset(reset), 		//置位
	.vga_data(vga_data), 	// 上 层 模 块 提 供 的 VGA颜色数据
	.h_addr(h_addr), 	// 提 供 给 上 层 模 块 的 当 前 扫 描 像 素 点 坐 标
	.v_addr(v_addr),
	.hsync(VGA_HS), 		// 行 同 步 和 列 同 步 信 号
	.vsync(VGA_VS),
	.valid(VGA_BLANK_N), 		//消隐信号
	.vga_r(VGA_R), 		// 红 绿 蓝 颜 色 信 号
	.vga_g(VGA_G),
	.vga_b(VGA_B)
);

initial begin
	endlink=5;
	k_x[0]=80;k_y[0]=9;k_v[0]=0;k_text[0]=8'd70;
	k_x[1]=90;k_y[1]=9;k_v[1]=0;k_text[1]=8'd66;
	k_x[2]=100;k_y[2]=9;k_v[2]=0;k_text[2]=8'd67;
	k_x[3]=110;k_y[3]=9;k_v[3]=0;k_text[3]=8'd68;
	k_x[4]=120;k_y[4]=9;k_v[4]=0;k_text[4]=8'd69;
end
//newin

//status
always @(posedge CLOCK_50 or posedge new_in)begin
	 if(new_in)begin
		 if(reset)begin status<=RESET; old_status<=none;cnt_newchar<=0;end
		 else if(flag==0) begin  cnt_newchar<=cnt_newchar+1; status<=key_event; old_status<=status;flag<=1; end
	 end else begin
		 	if(reset)begin status<=RESET; old_status<=none;cnt_newchar<=0; end
			else begin
				flag<=0;
				cnt_newchar<=cnt_newchar+1;
				if(cnt_newchar==TIME_NEW_CHAR)begin
					status<=create_new;
					cnt_newchar<=0;
				end else begin
					case (status)
						none 		: if(f_none) 		begin old_status<=status; status<=upt_pos;		end
						upt_pos		: if(f_upt_pos)		begin old_status<=status; status<=delete;		end //update pos
						delete 		: if(f_delete) 		begin old_status<=status; status<=draw_fst;		end
						draw_fst 	: if(f_draw_fst)	begin old_status<=status; status<=chg_mem;		end //first draw
						chg_mem  	: if(f_chg_mem) 	begin old_status<=status; status<=draw_sec;		end //change memory
						draw_sec 	: if(f_draw_sec)	begin old_status<=status; status<=none;			end //second draw
						RESET   	: if(!reset)		begin status<=none;								end
						key_event 	: if(f_key_event)	begin status<=old_status;						end //keyboard input
						create_new	: if(f_create_new)	begin status<=old_status;						end
						9,10,11,12,13,14,15 :           begin status<=none;	old_status<=none;			end
					endcase
				end
			end
	 end
end

//for our needed square, let it be what it should be, else let it be purple
always @(posedge CLOCK_50)begin
		if(h_addr<160 || h_addr>=480 || v_addr<140 ||v_addr>=340)begin
			vga_data<=24'h2a0a29;
		end else begin
			vga_data<=mem_dout==1?24'hffffff:24'h0;
		end
	end

//enw
always@(posedge CLOCK_50)begin
	if(status==draw_fst_cnt || status==draw_sec_cnt)
		canvas_enw<=1;
	else canvas_enw<=0;
	if(status==chg_mem)
		mem_enw<=1;
	else mem_enw<=0;
end

//all case
always @(posedge CLOCK_50)begin
	if(status==create_new)begin
		k_x[endlink]<=9'd123;
		k_y[endlink]<=8'd9;
		k_text[endlink]<=8'd65;
		k_v[endlink]<=1'd0;
		endlink<=endlink+1;
		f_create_new<=1;
	end else begin f_create_new<=0; end

	if(status==none)begin
		cnt<=cnt+1;
		if(cnt>=TIME)begin
			cnt<=0;
			f_none<=1;
		end
	end else begin f_none <=0;end

	if(status==upt_pos)begin
		if(upt_pos_cnt>=endlink)begin
			f_upt_pos<=1;
			upt_pos_cnt<=0;
		end else begin
			upt_pos_cnt<=upt_pos_cnt+1;
			if(k_v[upt_pos_cnt]==0)
				k_y[upt_pos_cnt]<=k_y[upt_pos_cnt]+1;
			else if(k_y[upt_pos_cnt]>3)
				k_y[upt_pos_cnt]<=k_y[upt_pos_cnt]-3;
		end
	end else begin f_upt_pos<=0; end

	if(status==delete)begin
		if(delete_cnt>=endlink)begin
			f_delete<=1;
			delete_cnt<=0;
			endlink<=delete_cnt-dnum;
			dnum<=0;
		end else begin
			delete_cnt<=delete_cnt+1;
			if(k_y[delete_cnt]<8)begin
				dnum<=dnum+1;
				hit<=hit+1;
			end else if(k_y[delete_cnt]>=193)begin
				dnum<=dnum+1;
				miss<=miss+1;
			end else begin
				k_x[delete_cnt]<=k_x[delete_cnt-dnum];
				k_y[delete_cnt]<=k_y[delete_cnt-dnum];
				k_text[delete_cnt]<=k_text[delete_cnt-dnum];
				k_v[delete_cnt]<=k_v[delete_cnt-dnum];
			end
		end
	end else begin f_delete<=0; end

	if(status==draw_fst)begin
		if(draw_fst_cnt>=endlink)begin
			f_draw_fst<=1;
			draw_fst_cnt<=0;
			x_fst<=0;
			y_fst<=0;
		end	else begin
			if(x_fst>=7)begin
				x_fst<=0;
				if(y_fst>=7)begin
					draw_fst_cnt<=draw_fst_cnt+1;
					y_fst<=0;
				end else begin
					y_fst<=y_fst+1;
				end
			end else begin
				x_fst<=x_fst+1;
			end
			canvas_y<=k_y[draw_fst_cnt]+y_fst;
			canvas_x<=k_x[draw_fst_cnt]+x_fst;
			char_pos<={k_text[draw_fst_cnt],y_fst};
			can_din<=char_row[7-x_fst];
		end
	end else begin f_draw_fst<=0; end

/*	if(status==draw_fst)begin
		if(x_fst>=7)begin
			x_fst<=0;
			if(y_fst>=7)begin
				f_draw_fst<=1;
				y_fst<=0;
			end else begin
				y_fst<=y_fst+1;
			end
		end else begin
			x_fst<=x_fst+1;
		end
		canvas_y<=y_fst;
		canvas_x<=x_fst;
		char_pos<={8'd65,y_fst};
		can_din<=char_row[x_fst];
	end
*/
	if(status==chg_mem)begin
		if(chg_mem_cnt>=200)begin
			f_chg_mem<=1;
			chg_mem_cnt<=0;
			mem_y<=0;
			mem_x<=0;
		end else begin
			if(mem_x+1>=320)begin
				mem_x<=0;
				chg_mem_cnt<=chg_mem_cnt+1;
				mem_y<=mem_y+1;
   			end else begin mem_x<=mem_x+1; end
		end
	end else begin f_chg_mem<=0; end

	if(status==draw_sec)begin
		if(draw_sec_cnt>=200)begin
			f_draw_sec<=1;
			draw_sec_cnt<=0;
			canvas_y<=0;
			canvas_x<=0;
		end else begin
			if(canvas_x+1>=320)begin
				draw_sec_cnt<=draw_sec_cnt+1;
				canvas_x<=0;
				canvas_y<=canvas_y+1;
		end else begin canvas_x<=canvas_x+1; end
		end
		can_din<=1'b0;
	end else begin draw_sec_cnt<=0; end

	if(status==key_event) begin
		if(f_key_event==0)begin
			if(key_event_cnt>=endlink)begin
				f_key_event<=1;
				key_event_cnt<=0;
			end else begin
				key_event_cnt<=key_event_cnt+1;

				if(k_text[key_event]==code_in)begin
					k_v[key_event_cnt]<=1;
					f_key_event<=1;
					key_event_cnt<=0;
				end
			end
		end else begin
			f_key_event<=1;
		end
 	end else begin f_key_event<=0; end

end

endmodule
